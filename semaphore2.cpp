#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <semaphore>

class Car
{

};


/*
* Задание 1.
Реализация в ООП!! 
Создать класс Car
Вместо ИД, название и гос номер.

Реализуйте модель парковки с ограниченным количеством мест.
На парковке всего 3 места. Несколько машин (потоков) пытаются припарковаться.
Каждая машина должна:

«Подъехать» к парковке (вывести сообщение).
Ждать свободного места, если парковка занята.
Припарковаться, заняв одно место.
Постять на парковке некоторое фиксированное время (например, 1 секунду).
Уехать, освободив место.
Разбудить одну из ожидающих машин.

Количество машин (потоков) — не менее 6.
Вывод программы должен ясно показывать, что одновременно припарковано не более трёх машин.

-------------------------------------------------------------
Задание 2.
Создайте программу, в которой:
Есть один текстовый файл (например, log.txt).
Есть несколько потоков (не меньше 6).

Каждый поток должен:

начать работу и вывести сообщение;
попытаться записать свою строку в файл;
но доступ к файлу ограничен семафором на 2 пропуска
(то есть одновременно в файл могут писать только 2 потока).


Поток, получивший доступ, записывает строку вида:
 "Поток X записал данные"
После записи поток освобождает место в семафоре.

Файл должен корректно показывать записи, без перемешивания и обрывов.

Задание 3
Создайте программу, в которой:

Есть глобальный массив из 20 элементов (например int data[20];), изначально заполненный нулями.

Есть несколько потоков (например 5).

Каждый поток должен:
получить «разрешение» от семафора (например на 2 пропуска),
найти первый нулевой элемент массива,
записать туда номер потока (или любое своё значение),
освободить разрешение семафора.

Работа продолжается, пока весь массив не будет заполнен.

После завершения работы программа выводит массив.

Важно:
Необходимо предотвратить ситуацию, когда два потока одновременно пытаются записать в один и тот же индекс.
*/
std::counting_semaphore<3> parking(3);
// 3 свободных места на парковке

void car(int id) {
    using namespace std::chrono;

    std::cout << "Машина " << id << " подъехала и пытается припарковаться...\n";

    // Ожидание свободного места, если мест нет — поток блокируется
    parking.acquire();
    std::cout << "Машина " << id << " припарковалась.\n";

    // Машина стоит на парковке фиксированное время
    std::this_thread::sleep_for(seconds(1));

    std::cout << "Машина " << id << " уехала.\n";
    parking.release(); // освобождение места
}

int main() {
    setlocale(0, "ru");
    std::vector<std::thread> cars;

    // Пусть подъедут 6 машин
    for (int i = 1; i <= 6; ++i) {
        cars.emplace_back(car, i);
    }

    for (auto& t : cars) t.join();

    std::cout << "Парковка свободна. Все машины обработаны.\n";
    return 0;
}
/*
Одновременно паркуются не более 3 машин, потому что семафор ограничивает доступ.
Остальные автомобили ожидают, пока кто‑то не вызовет parking.release().
Логика потоков полностью детерминирована, нет случайных задержек.
*/

